import { createHmac, randomBytes } from 'crypto';
import { sign, verify } from 'jsonwebtoken';

/**
 * Supported signing algorithms.
 */
type Algorithm =
    | "HS256" | "HS384" | "HS512"
    | "RS256" | "RS384" | "RS512"
    | "ES256" | "ES384" | "ES512"
    | "PS256" | "PS384" | "PS512"
    | "none";

/**
 * Generates a JWT token.
 * @param data - The data payload to be included in the token.
 * @param tokenSecret - The secret key used for token generation.
 * @param expiresIn - The expiration time for the token (optional, defaults to '24h').
 * @param algorithm - The signing algorithm to be used (optional, defaults to "HS256").
 * @returns An object containing the generated token and success status.
 */
export function generateToken({
    data = {},
    tokenSecret,
    expiresIn = '24h',
    algorithm = "HS256"
}: {
    algorithm?: Algorithm;
    data: object;
    tokenSecret: any;
    expiresIn?: any;
}) {
    try {
        return {
            token: sign(data, tokenSecret, {
                expiresIn: expiresIn,
                algorithm: algorithm
            }),
            success: true
        };
    }
    catch (err) {
        return {
            token: null,
            message: err,
            success: false
        };
    }
}

/**
 * Decodes a JWT token.
 * @param tokenSecret - The secret key used for token verification.
 * @param token - The JWT token to be decoded.
 * @returns An object containing the decoded data and success status.
 */
export function decodedToken(
    {
        tokenSecret = process.env.TOKEN_SECRET,
        token
    }: {
        tokenSecret?: string | any,
        token?: string | any
    }
) {
    try {
        return {
            data: verify(token, tokenSecret),
            success: true
        };
    }
    catch (err: any) {
        return {
            data: null,
            success: false,
            message: err.message
        };
    }
}

/**
 * Enum defining hashing algorithms.
 */
enum HashAlgorithm {
    SHA1 = 'sha1',
    SHA256 = 'sha256',
    SHA384 = 'sha384',
    SHA512 = 'sha512',
    MD5 = 'md5',
}

let length = 16;

/**
 * Refreshes a token encoded.
 * @param hashedPass - The hashed password (optional). It makes more secure..
 * @param data - Additional data to be included in the token.
 * @param expiresIn - The expiration time for the token (optional).
 * @param tokenSecret - The secret key used for token generation.
 * @returns The refreshed token or null if hashedPass is not provided.
 */
export function refreshTokenEncoded({
    hashedPass,
    data = {},
    expiresIn,
    tokenSecret
}: {
    email?: string | any,
    hashedPass?: any,
    data?: Object,
    account?: string | any,
    tokenSecret: string,
    expiresIn?: string //'7 days','3 days'
}) {
    // (B1) GENERATE RANDOM SALT
    let ref_tkn_data: { sessionToken?: string, data?: Object } = {};
    ref_tkn_data.data = data;

    if (hashedPass) {
        const { hash, salt } = passwordHashing({
            password: hashedPass
        })
        ref_tkn_data.sessionToken = `${salt}####${hash}`
    }
    else {
        const refreshTokenGen = generateToken({
            data: ref_tkn_data,
            expiresIn: expiresIn,
            tokenSecret: tokenSecret
        }).token;

        return refreshTokenGen;
    }
};

/**
 * Hashes a password.
 * @param salt - The salt used for hashing (optional, autogenerated if not provided).
 * @param password - The password to be hashed.
 * @param algorithm - The hashing algorithm to be used (optional, defaults to SHA256).
 * @param encoding - The encoding format for the hash (optional, defaults to 'base64').
 * @returns An object containing the salt, success status, and hashed password.
 */
export function passwordHashing({
    salt = randomBytes(Math.ceil(length / 2)).toString("hex").slice(0, length),
    password = '',
    algorithm = HashAlgorithm.SHA256,
    encoding = 'base64'
}: {
    salt?: string,
    algorithm?: HashAlgorithm
    password?: string,
    encoding?: "base64" | "hex"
}) {
    try {
        // (B2) SHA512 HASH
        let hash = createHmac(algorithm, salt);
        hash.update(password);
        return {
            salt: salt,
            success: true,
            hash: hash.digest(encoding)
        };
    }
    catch (err: any) {
        return {
            success: false,
            salt: undefined,
            hash: undefined,
            message: err.message
        };
    }
};

/**
 * Checks if a password matches the hashed value.
 * @param salt - The salt used for hashing.
 * @param hash - The hashed password to be checked.
 * @param password - The password to be validated.
 * @returns True if the password matches the hash, false otherwise.
 */
export function checkPassword({
    salt,
    hash,
    password
}: {
    password: string,
    hash: string | undefined
    salt: string | undefined
}) {
    return passwordHashing({
        salt: salt,
        password: password
    })?.hash == hash;
};


// const { salt, hash } = passwordHashing({ password: "1234" });
// console.log(checkPassword({ hash: hash, password: '1234', salt: salt }));